.TH "set" 1 "Tue Feb 19 2019" "Version 3.0.2" "fish" \" -*- nroff -*-
.ad l
.nh
.SH NAME
\fBset\fP - display and change shell variables\&.
.PP
.SS "Synopsis"
.PP
.nf

\fBset\fP [SCOPE_OPTIONS]
\fBset\fP [OPTIONS] VARIABLE_NAME VALUES\&.\&.\&.
\fBset\fP [OPTIONS] VARIABLE_NAME[INDICES]\&.\&.\&. VALUES\&.\&.\&.
\fBset\fP ( -q | --query ) [SCOPE_OPTIONS] VARIABLE_NAMES\&.\&.\&.
\fBset\fP ( -e | --erase ) [SCOPE_OPTIONS] VARIABLE_NAME
\fBset\fP ( -e | --erase ) [SCOPE_OPTIONS] VARIABLE_NAME[INDICES]\&.\&.\&.
\fBset\fP ( -S | --show ) [SCOPE_OPTIONS] [VARIABLE_NAME]\&.\&.\&.
.fi
.PP
.SS "Description"
\fCset\fP manipulates \fCshell variables\fP\&.
.PP
If set is called with no arguments, the names and values of all shell variables are printed in sorted order\&. If some of the scope or export flags have been given, only the variables matching the specified scope are printed\&.
.PP
With both variable names and values provided, \fCset\fP assigns the variable \fCVARIABLE_NAME\fP the values \fCVALUES\&.\&.\&.\fP\&.
.PP
The following options control variable scope:
.PP
.IP "\(bu" 2
\fC-a\fP or \fC--append\fP causes the values to be appended to the current set of values for the variable\&. This can be used with \fC--prepend\fP to both append and prepend at the same time\&. This cannot be used when assigning to a variable slice\&.
.IP "\(bu" 2
\fC-p\fP or \fC--prepend\fP causes the values to be prepended to the current set of values for the variable\&. This can be used with \fC--append\fP to both append and prepend at the same time\&. This cannot be used when assigning to a variable slice\&.
.IP "\(bu" 2
\fC-l\fP or \fC--local\fP forces the specified shell variable to be given a scope that is local to the current block, even if a variable with the given name exists and is non-local
.IP "\(bu" 2
\fC-g\fP or \fC--global\fP causes the specified shell variable to be given a global scope\&. Non-global variables disappear when the block they belong to ends
.IP "\(bu" 2
\fC-U\fP or \fC--universal\fP causes the specified shell variable to be given a universal scope\&. If this option is supplied, the variable will be shared between all the current user's fish instances on the current computer, and will be preserved across restarts of the shell\&.
.IP "\(bu" 2
\fC-x\fP or \fC--export\fP causes the specified shell variable to be exported to child processes (making it an 'environment variable')
.IP "\(bu" 2
\fC-u\fP or \fC--unexport\fP causes the specified shell variable to NOT be exported to child processes
.PP
.PP
The following options are available:
.PP
.IP "\(bu" 2
\fC-e\fP or \fC--erase\fP causes the specified shell variable to be erased
.IP "\(bu" 2
\fC-q\fP or \fC--query\fP test if the specified variable names are defined\&. Does not output anything, but the builtins exit status is the number of variables specified that were not defined\&.
.IP "\(bu" 2
\fC-n\fP or \fC--names\fP List only the names of all defined variables, not their value\&. The names are guaranteed to be sorted\&.
.IP "\(bu" 2
\fC-S\fP or \fC--show\fP Shows information about the given variables\&. If no variable names are given then all variables are shown in sorted order\&. No other flags can be used with this option\&. The information shown includes whether or not it is set in each of the local, global, and universal scopes\&. If it is set in one of those scopes whether or not it is exported is reported\&. The individual elements are also shown along with the length of each element\&.
.IP "\(bu" 2
\fC-L\fP or \fC--long\fP do not abbreviate long values when printing set variables
.PP
.PP
If a variable is set to more than one value, the variable will be an array with the specified elements\&. If a variable is set to zero elements, it will become an array with zero elements\&.
.PP
If the variable name is one or more array elements, such as \fCPATH[1 3 7]\fP, only those array elements specified will be changed\&. If you specify a negative index when expanding or assigning to an array variable, the index will be calculated from the end of the array\&. For example, the index -1 means the last index of an array\&.
.PP
The scoping rules when creating or updating a variable are:
.PP
.IP "1." 4
Variables may be explicitly set to universal, global or local\&. Variables with the same name in different scopes will not be changed\&.
.IP "2." 4
If a variable is not explicitly set to be either universal, global or local, but has been previously defined, the previous variable scope is used\&.
.IP "3." 4
If a variable is not explicitly set to be either universal, global or local and has never before been defined, the variable will be local to the currently executing function\&. Note that this is different from using the \fC-l\fP or \fC--local\fP flag\&. If one of those flags is used, the variable will be local to the most inner currently executing block, while without these the variable will be local to the function\&. If no function is executing, the variable will be global\&.
.PP
.PP
The exporting rules when creating or updating a variable are identical to the scoping rules for variables:
.PP
.IP "1." 4
Variables may be explicitly set to either exported or not exported\&. When an exported variable goes out of scope, it is unexported\&.
.IP "2." 4
If a variable is not explicitly set to be exported or not exported, but has been previously defined, the previous exporting rule for the variable is kept\&.
.IP "3." 4
If a variable is not explicitly set to be either exported or unexported and has never before been defined, the variable will not be exported\&.
.PP
.PP
In query mode, the scope to be examined can be specified\&.
.PP
In erase mode, if variable indices are specified, only the specified slices of the array variable will be erased\&.
.PP
\fCset\fP requires all options to come before any other arguments\&. For example, \fCset flags -l\fP will have the effect of setting the value of the variable \fCflags\fP to '-l', not making the variable local\&.
.PP
In assignment mode, \fCset\fP does not modify the exit status\&. This allows simultaneous capture of the output and exit status of a subcommand, e\&.g\&. \fCif set output (command)\fP\&. In query mode, the exit status is the number of variables that were not found\&. In erase mode, \fCset\fP exits with a zero exit status in case of success, with a non-zero exit status if the commandline was invalid, if the variable was write-protected or if the variable did not exist\&.
.SS "Examples"
.PP
.nf

  Prints all global, exported variables\&.
\fBset\fP -xg
.fi
.PP
.PP
.PP
.nf
  Sets the value of the variable $foo to be 'hi'\&.
\fBset\fP foo hi
.fi
.PP
.PP
.PP
.nf
  Appends the value 'there' to the variable $foo\&.
\fBset\fP -a foo there
.fi
.PP
.PP
.PP
.nf
  Does the same thing as the previous two commands the way it would be done pre-fish 3\&.0\&.
\fBset\fP foo hi
\fBset\fP foo $foo there
.fi
.PP
.PP
.PP
.nf
  Removes the variable $smurf
\fBset\fP -e smurf
.fi
.PP
.PP
.PP
.nf
  Changes the fourth element of the $PATH array to ~/bin
\fBset\fP PATH[4] ~/bin
.fi
.PP
.PP
.PP
.nf
  Outputs the path to Python if `type -p` returns true\&.
\fBif\fP \fBset\fP python_path (\fBtype\fP -p python)
    \fBecho\fP 'Python is at $python_path'
\fBend\fP
.fi
.PP
.SS "Notes"
Fish versions prior to 3\&.0 supported the syntax \fCset PATH[1] PATH[4] /bin /sbin\fP, which worked like \fCset PATH[1 4] /bin /sbin\fP\&. This syntax was not widely used, and was ambiguous and inconsistent\&. 
